#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

// UNSIGNED INTEGERS
typedef unsigned long long int u64;
u64 MAX_U64 = 18446744073709551615uLL;
u64 nondet_u64() {
    u64 x;
    __ESBMC_assume(x <= MAX_U64);
    return x;
}

typedef unsigned long long int u32;
u32 MAX_U32 = 4294967295uLL;
u32 nondet_u32() {
    u32 x;
    __ESBMC_assume(x <= MAX_U32);
    return x;
}

typedef unsigned long long int u16;
u16 MAX_U16 = 65535uLL;
u16 nondet_u16() {
    u16 x;
    __ESBMC_assume(x <= MAX_U16);
    return x;
}

typedef unsigned long long int u8;
u8 MAX_U8 = 255uLL;
u8 nondet_u8() {
    u8 x;
    __ESBMC_assume(x <= MAX_U8);
    return x;
}

typedef u64 usize;
usize MAX_USIZE = 18446744073709551615uLL;
usize nondet_usize() {
    usize x;
    __ESBMC_assume(x <= MAX_USIZE);
    return x;
}

// SIGNED INTEGERS
typedef signed long long int i64;
i64 MIN_I64 = -9223372036854775807LL - 1;
i64 MAX_I64 = 9223372036854775807LL;
i64 nondet_i64() {
    i64 x;
    __ESBMC_assume(x >= MIN_I64);
    __ESBMC_assume(x <= MAX_I64);
    return x;
}

typedef signed long long int i32;
i32 MIN_I32 = -2147483648LL;
i32 MAX_I32 = 2147483647LL;
i32 nondet_i32() {
    i32 x;
    __ESBMC_assume(x >= MIN_I32);
    __ESBMC_assume(x <= MAX_I32);
    return x;
}

typedef signed long long int i16;
i16 MIN_I16 = -32768LL;
i16 MAX_I16 = 32767LL;
i16 nondet_i16() {
    i16 x;
    __ESBMC_assume(x >= MIN_I16);
    __ESBMC_assume(x <= MAX_I16);
    return x;
}

typedef signed long long int i8;
i8 MIN_I8 = -128LL;
i8 MAX_I8 = 127LL;
i8 nondet_i8() {
    i8 x;
    __ESBMC_assume(x >= MIN_I8);
    __ESBMC_assume(x <= MAX_I8);
    return x;
}

typedef i64 isize;
isize MIN_ISIZE = -9223372036854775807LL - 1;
isize MAX_ISIZE = 9223372036854775807LL;
isize nondet_isize() {
    isize x;
    __ESBMC_assume(x >= MIN_ISIZE);
    __ESBMC_assume(x <= MAX_ISIZE);
    return x;
}

// FLOATING NUMBERS
typedef double f64;
f64 MIN_F64 = -1.7976931348623157E+308;
f64 MAX_F64 = 1.7976931348623157E+308;
f64 nondet_f64() {
    f64 x;
    __ESBMC_assume(x >= MIN_F64);
    __ESBMC_assume(x <= MAX_F64);
    return x;
}

typedef double f32;
f32 MIN_F32 = -3.40282347E+38;
f32 MAX_F32 = 3.40282347E+38;
f32 nondet_f32() {
    f32 x;
    __ESBMC_assume(x >= MIN_F32);
    __ESBMC_assume(x <= MAX_F32);
    return x;
}

// MATH OPERATORS
typedef struct unsigned_math_result_struct {
    unsigned long long int value;
    bool errors;
} unsigned_math_result;

typedef struct signed_math_result_struct {
    signed long long int value;
    bool errors;
} signed_math_result;

typedef struct float_math_result_struct {
    double value;
    bool errors;
} float_math_result;

unsigned_math_result u_addition(unsigned long long int a, unsigned long long int b, unsigned long long int max) {
    unsigned_math_result result;
    result.value = a + b;
    result.errors = a > max - b;
    __ESBMC_assert(!result.errors, "Vulnerability Found: 0");
    return result;
}

signed_math_result i_addition(signed long long int a, signed long long int b, signed long long int max, signed long long int min) {
    signed_math_result result;
    result.value = a + b;
    if (b < 0) {
        result.errors = a < min - b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 1");
    } else {
        result.errors = a > max - b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 0");
    }
    return result;
}

float_math_result f_addition(double a, double b, double max, double min) {
    float_math_result result;
    result.value = a + b;
    if (b < 0) {
        result.errors = a < min - b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 1");
    } else {
        result.errors = a > max - b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 0");
    }
    return result;
}

unsigned_math_result u_subtraction(unsigned long long int a, unsigned long long int b, unsigned long long int max) {
    unsigned_math_result result;
    result.value = a - b;
    result.errors = a < b;
    __ESBMC_assert(!result.errors, "Vulnerability Found: 3");
    return result;
}

signed_math_result i_subtraction(signed long long int a, signed long long int b, signed long long int max, signed long long int min) {
    signed_math_result result;
    result.value = a - b;
    if (b < 0) {
        result.errors = a > max + b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 2");
    } else {
        result.errors = a < min + b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 3");
    }
    return result;
}

float_math_result f_subtraction(double a, double b, double max, double min) {
    float_math_result result;
    result.value = a - b;
    if (b < 0) {
        result.errors = a > max + b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 2");
    } else {
        result.errors = a < min + b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 3");
    }
    return result;
}

unsigned_math_result u_multiplication(unsigned long long int a, unsigned long long int b, unsigned long long int max) {
    unsigned_math_result result;
    result.value = a * b;
    if (b == 0) {
        result.errors = false;
    } else {
        result.errors = a > max / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 4");
    }
    return result;
}

signed_math_result i_multiplication(signed long long int a, signed long long int b, signed long long int max, signed long long int min) {
    signed_math_result result;
    result.value = a * b;
    if (b == 0) {
        result.errors = false;
    } else if ((b > 0) && (a > 0)) {
        result.errors = a > max / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 4");
    } else if ((b < 0) && (a < 0)) {
        result.errors = a < max / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 4");
    } else if ((b > 0) && (a < 0)) {
        result.errors = a < min / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 5");
    } else if ((b < 0) && (a > 0)) {
        result.errors = a > min / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 5");
    }
    return result;
}

float_math_result f_multiplication(double a, double b, double max, double min) {
    float_math_result result;
    result.value = a * b;
    if (b == 0) {
        result.errors = false;
    } else if ((b > 0) && (a > 0)) {
        result.errors = a > max / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 4");
    } else if ((b < 0) && (a < 0)) {
        result.errors = a < max / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 4");
    } else if ((b > 0) && (a < 0)) {
        result.errors = a < min / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 5");
    } else if ((b < 0) && (a > 0)) {
        result.errors = a > min / b;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 5");
    }
    return result;
}

unsigned_math_result u_division(unsigned long long int a, unsigned long long int b, unsigned long long int max) {
    unsigned_math_result result;
    result.value = a / b;
    if (b == 0) {
        result.errors = true;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 7");
    } else {
        result.errors = false;
    }
    return result;
}

signed_math_result i_division(signed long long int a, signed long long int b, signed long long int max, signed long long int min) {
    signed_math_result result;
    result.value = a / b;
    if (b == 0) {
        result.errors = true;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 7");
    } else if (b == -1) {
        result.errors = a == min;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 6");
    } else {
        result.errors = false;
    }
    return result;
}

float_math_result f_division(double a, double b, double max, double min) {
    float_math_result result;
    result.value = a / b;
    if (b == 0) {
        result.errors = true;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 7");
    } else if (b == -1) {
        result.errors = a == min;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 6");
    } else {
        result.errors = false;
    }
    return result;
}

unsigned_math_result u_negation(unsigned long long int a, unsigned long long int max) {
    unsigned_math_result result;
    result.value = -a;
    result.errors = true;
    __ESBMC_assert(!result.errors, "Vulnerability Found: 12");
    return result;
}

signed_math_result i_negation(signed long long int a, signed long long int max, signed long long int min) {
    signed_math_result result;
    result.value = -a;
    if (a == min) {
        result.errors = true;
        __ESBMC_assert(!result.errors, "Vulnerability Found: 8");
    } else {
        result.errors = false;
    }
    return result;
}

float_math_result f_negation(double a, double max) {
    float_math_result result;
    result.value = -a;
    result.errors = false;
    return result;
}

// STRING
typedef char* string;
string nondet_string() {
    char* str;
    return str;
}
void print(string s) {
    printf("%s\n", s);
}
bool is_equal_string(string lhs, string rhs) {
    return strcmp(lhs, rhs) == 0;
}

// PUBKEY
typedef struct pubkey_struct {
    u8 p0;
    u8 p1;
    u8 p2;
    u8 p3;
    u8 p4;
    u8 p5;
    u8 p6;
    u8 p7;
    u8 p8;
    u8 p9;
    u8 p10;
    u8 p11;
    u8 p12;
    u8 p13;
    u8 p14;
    u8 p15;
    u8 p16;
    u8 p17;
    u8 p18;
    u8 p19;
    u8 p20;
    u8 p21;
    u8 p22;
    u8 p23;
    u8 p24;
    u8 p25;
    u8 p26;
    u8 p27;
    u8 p28;
    u8 p29;
    u8 p30;
    u8 p31;
} pubkey;
pubkey nondet_pubkey() {
    pubkey p;
    p.p0 = nondet_u8();
    p.p1 = nondet_u8();
    p.p2 = nondet_u8();
    p.p3 = nondet_u8();
    p.p4 = nondet_u8();
    p.p5 = nondet_u8();
    p.p6 = nondet_u8();
    p.p7 = nondet_u8();
    p.p8 = nondet_u8();
    p.p9 = nondet_u8();
    p.p10 = nondet_u8();
    p.p11 = nondet_u8();
    p.p12 = nondet_u8();
    p.p13 = nondet_u8();
    p.p14 = nondet_u8();
    p.p15 = nondet_u8();
    p.p16 = nondet_u8();
    p.p17 = nondet_u8();
    p.p18 = nondet_u8();
    p.p19 = nondet_u8();
    p.p20 = nondet_u8();
    p.p21 = nondet_u8();
    p.p22 = nondet_u8();
    p.p23 = nondet_u8();
    p.p24 = nondet_u8();
    p.p25 = nondet_u8();
    p.p26 = nondet_u8();
    p.p27 = nondet_u8();
    p.p28 = nondet_u8();
    p.p29 = nondet_u8();
    p.p30 = nondet_u8();
    p.p31 = nondet_u8();
    return p;
}
bool is_equal_pubkey(pubkey lhs, pubkey rhs) {
    return lhs.p0 == rhs.p0 && lhs.p1 == rhs.p1 && lhs.p2 == rhs.p2 &&
        lhs.p3 == rhs.p3 && lhs.p4 == rhs.p4 && lhs.p5 == rhs.p5 &&
        lhs.p6 == rhs.p6 && lhs.p7 == rhs.p7 && lhs.p8 == rhs.p8 &&
        lhs.p9 == rhs.p9 && lhs.p10 == rhs.p10 && lhs.p11 == rhs.p11 &&
        lhs.p12 == rhs.p12 && lhs.p13 == rhs.p13 && lhs.p14 == rhs.p14 &&
        lhs.p15 == rhs.p15 && lhs.p16 == rhs.p16 && lhs.p17 == rhs.p17 &&
        lhs.p18 == rhs.p18 && lhs.p19 == rhs.p19 && lhs.p20 == rhs.p20 &&
        lhs.p21 == rhs.p21 && lhs.p22 == rhs.p22 && lhs.p23 == rhs.p23 &&
        lhs.p24 == rhs.p24 && lhs.p25 == rhs.p25 && lhs.p26 == rhs.p26 &&
        lhs.p27 == rhs.p27 && lhs.p28 == rhs.p28 && lhs.p29 == rhs.p29 &&
        lhs.p30 == rhs.p30 && lhs.p31 == rhs.p31;
}

// ACCOUNT INFO
typedef struct account_info_struct {
    pubkey get0;
    u64 get1;
    u8 get2[{{ARRAY_SIZE}}];
    pubkey get3;
    u64 get4;
    bool get5;
    bool get6;
    bool get7;
} account_info;
account_info nondet_account_info() {
    account_info info;
    info.get0 = nondet_pubkey();
    info.get1 = nondet_u64();
    for (int i = 0; i < {{ARRAY_SIZE}}; i++) {
        info.get2[i] = nondet_u8();
    }
    info.get3 = nondet_pubkey();
    info.get4 = nondet_u64();
    info.get5 = nondet_bool();
    info.get6 = nondet_bool();
    info.get7 = nondet_bool();
    return info;
}

// ACCOUNT META
typedef struct account_meta_struct {
    pubkey get0;
    bool get1;
    bool get2;
} account_meta;
account_meta nondet_account_meta() {
    account_meta meta;
    meta.get0 = nondet_pubkey();
    meta.get1 = nondet_bool();
    meta.get2 = nondet_bool();
    return meta;
}

// INSTRUCTION
typedef struct solana_instruction_struct {
    pubkey get0;
    account_meta get1[{{ARRAY_SIZE}}];
    u8 get2[{{ARRAY_SIZE}}];
} solana_instruction;
solana_instruction nondet_solana_instruction() {
    solana_instruction instruction;
    instruction.get0 = nondet_pubkey();
    for (int i = 0; i < {{ARRAY_SIZE}}; i++) {
        instruction.get1[i] = nondet_account_meta();
    }
    for (int i = 0; i < {{ARRAY_SIZE}}; i++) {
        instruction.get2[i] = nondet_u8();
    }
    return instruction;
}

// INFALLIBLE
typedef enum { unreachable } infallible;
infallible nondet_infallible() {
    infallible i;
    return i;
}

// CONTROL FLOW
typedef enum { _continue, _break } controlflow;
controlflow nondet_controlflow() {
    controlflow c;
    return c;
}

// PANIC ASSERT KIND
typedef enum { _panic_assert_kind_eq, _panic_assert_kind_ne, _panic_assert_kind_match } panic_assert_kind;
panic_assert_kind nondet_panic_assert_kind() {
    panic_assert_kind x;
    return x;
}

// ALIGNMENT
typedef enum { _alignment_left, _alignment_right, _alignment_center, _alignment_unknown } alignment;
alignment nondet_alignment() {
    alignment x;
    return x;
}

// COUNT
typedef enum { _count_is, _count_param, _count_implied } count;
count nondet_count() {
    count x;
    return x;
}

// PLACEHOLDER
typedef struct placeholder_struct {
    usize get0;
    char get1;
    alignment get2;
    u32 get3;
    count get4;
    count get5;
} placeholder;
placeholder nondet_placeholder() {
    placeholder x;
    x.get0 = nondet_usize();
    x.get1 = nondet_char();
    x.get2 = nondet_alignment();
    x.get3 = nondet_u32();
    x.get4 = nondet_count();
    x.get5 = nondet_count();
    return x;
}

typedef struct solana_asset_placeholder_array_optional_struct {
    bool is_none;
    placeholder value[{{ARRAY_SIZE}}];
} solana_asset_placeholder_array_optional;
solana_asset_placeholder_array_optional nondet_solana_asset_placeholder_array_optional() {
    solana_asset_placeholder_array_optional x;
    x.is_none = nondet_bool();
    for (int i = 0; i < {{ARRAY_SIZE}}; i++) {
        x.value[i] = nondet_placeholder();
    }
    return x;
}

// ARGUMENT
typedef struct argument_struct {
    string get0;
} argument;
argument nondet_argument() {
    argument x;
    x.get0 = nondet_string();
    return x;
}

// ARGUMENTS
typedef struct arguments_struct {
    string get0[{{ARRAY_SIZE}}];
    solana_asset_placeholder_array_optional get1;
    argument get2[{{ARRAY_SIZE}}];
} arguments;
arguments nondet_arguments() {
    arguments x;
    for (int i = 0; i < {{ARRAY_SIZE}}; i++) {
        x.get0[i] = nondet_string();
    }
    x.get1 = nondet_solana_asset_placeholder_array_optional();
    for (int i = 0; i < {{ARRAY_SIZE}}; i++) {
        x.get2[i] = nondet_argument();
    }
    return x;
}
